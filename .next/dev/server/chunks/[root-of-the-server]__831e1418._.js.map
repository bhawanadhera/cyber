{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/mohitkumar/Downloads/code%20%282%29/app/api/analyze/route.ts"],"sourcesContent":["// app/api/analyze/route.ts\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { Client } from \"@gradio/client\";\n\ntype GraphData = {\n  data: any[];\n  layout: Record<string, any>;\n};\n\n// ----------------- Helper Functions -----------------\nfunction parseReport(report: string) {\n  const get = (key: string) => {\n    // Use a loose regex that captures until end of line\n    const re = new RegExp(`${key}:\\\\s*([^\\\\n\\\\r]*)`, \"i\");\n    const match = report.match(re);\n    return match ? match[1].trim() : null;\n  };\n\n  const confidenceRaw = get(\"Confidence Score\") ?? \"0\";\n  const confidence = parseFloat(confidenceRaw) || 0;\n\n  return {\n    confidence,\n    firstSeen: get(\"First Seen\"),\n    lastSeen: get(\"Last Seen\"),\n    tags: (get(\"Tags\") || \"\")\n      .split(\",\")\n      .map((t) => t.trim())\n      .filter(Boolean),\n    predictedThreat: get(\"Predicted Threat Level\") || \"Unknown\",\n  };\n}\n\nfunction buildGauge(confidence: number, predictedThreat: string): GraphData {\n  // Typed ranges\n  const gaugeColors: [number, number, string][] = [\n    [0, 0.4, \"#16a34a\"], // green\n    [0.4, 0.75, \"#f59e0b\"], // yellow/orange\n    [0.75, 1, \"#dc2626\"], // red\n  ];\n\n  return {\n    data: [\n      {\n        type: \"indicator\",\n        mode: \"gauge+number+delta\",\n        value: confidence,\n        title: {\n          text: `<b>Confidence</b><br><span style=\"font-size:12px;color:#cbd5e1\">Threat: ${predictedThreat}</span>`,\n          font: { size: 16 },\n        },\n        number: { suffix: \"%\" },\n        gauge: {\n          axis: { range: [0, 100], tickwidth: 1, tickcolor: \"#94a3b8\" },\n          bar: { color: \"#0ea5a6\" },\n          steps: gaugeColors.map(([s, e, color]) => ({\n            range: [s * 100, e * 100],\n            color,\n          })),\n          threshold: {\n            line: { color: \"#111827\", width: 4 },\n            thickness: 0.8,\n            value: confidence,\n          },\n        },\n      },\n    ],\n    layout: {\n      title: { text: \"Threat Confidence Gauge\", font: { color: \"#e2e8f0\" } },\n      margin: { t: 40, b: 20, l: 10, r: 10 },\n      paper_bgcolor: \"#0b1220\",\n      plot_bgcolor: \"#0b1220\",\n      font: { color: \"#e2e8f0\" },\n      height: 360,\n      width: 360,\n    },\n  };\n}\n\nfunction buildTimeline(firstSeen: string | null, lastSeen: string | null): GraphData {\n  const fsDate = firstSeen ? new Date(firstSeen) : new Date();\n  const lsDate = lastSeen ? new Date(lastSeen) : new Date();\n\n  // friendly labels\n  const fmt = (d: Date) =>\n    d.toLocaleString(undefined, { year: \"numeric\", month: \"short\", day: \"numeric\" });\n\n  const fsLabel = fmt(fsDate);\n  const lsLabel = fmt(lsDate);\n\n  return {\n    data: [\n      // invisible baseline (helps with the fill polygon)\n      {\n        x: [fsDate, lsDate],\n        y: [1, 1],\n        mode: \"lines\",\n        line: { color: \"transparent\" },\n        hoverinfo: \"skip\",\n        showlegend: false,\n      },\n      // filled rectangular band between first and last seen\n      {\n        type: \"scatter\",\n        x: [fsDate, lsDate, lsDate, fsDate, fsDate],\n        y: [0.6, 0.6, 1.4, 1.4, 0.6],\n        fill: \"toself\",\n        fillcolor: \"rgba(14,116,144,0.18)\",\n        line: { color: \"rgba(14,116,144,0)\" },\n        hoverinfo: \"skip\",\n        showlegend: false,\n      },\n      // First Seen marker + label\n      {\n        x: [fsDate],\n        y: [1],\n        mode: \"markers+text\",\n        marker: { size: 14, color: \"#06b6d4\", line: { width: 2, color: \"#0f172a\" } },\n        text: [`First: ${fsLabel}`],\n        textposition: \"bottom center\",\n        textfont: { color: \"#06b6d4\", size: 12 },\n        hovertemplate: `First Seen: ${fsLabel}<extra></extra>`,\n      },\n      // Last Seen marker + label\n      {\n        x: [lsDate],\n        y: [1],\n        mode: \"markers+text\",\n        marker: { size: 14, color: \"#60a5fa\", line: { width: 2, color: \"#0f172a\" } },\n        text: [`Last: ${lsLabel}`],\n        textposition: \"bottom center\",\n        textfont: { color: \"#60a5fa\", size: 12 },\n        hovertemplate: `Last Seen: ${lsLabel}<extra></extra>`,\n      },\n    ],\n    layout: {\n      title: { text: \"Threat Levels Over Time\", font: { size: 18 } },\n      xaxis: {\n        title: \"Last Seen\",\n        showgrid: true,\n        gridcolor: \"#1f2937\",\n        tickangle: -25,\n        tickfont: { color: \"#cbd5e1\" },\n      },\n      yaxis: { visible: false, range: [0, 2] },\n      margin: { t: 60, b: 80, l: 40, r: 40 },\n      paper_bgcolor: \"#0b1220\",\n      plot_bgcolor: \"#0b1220\",\n      font: { color: \"#e2e8f0\" },\n      height: 330,\n      width: 580, // wider to make it look like your screenshot\n    },\n  };\n}\n\n// ----------------- API Route -----------------\nexport async function POST(req: NextRequest) {\n  try {\n    const body = await req.json();\n    const { user_input } = body;\n\n    if (!user_input) {\n      return NextResponse.json({ error: \"Input is required\" }, { status: 400 });\n    }\n\n    // connect to Gradio Space (your space)\n    const client = await Client.connect(\"Bha19/cyber_project\");\n    const result = await client.predict(\"/predict\", { user_input });\n\n    // result.data is expected to be [report, maybe-other]\n    const dataArray = result.data as [string, string | null];\n    const [report] = dataArray;\n\n    // parse report\n    const { confidence, firstSeen, lastSeen, predictedThreat } = parseReport(report);\n\n    // build graphs\n    const graphs: GraphData[] = [buildGauge(confidence, predictedThreat), buildTimeline(firstSeen, lastSeen)];\n\n    return NextResponse.json({ report, graph: graphs });\n  } catch (err) {\n    console.error(\"Error calling Gradio API:\", err);\n    return NextResponse.json({ error: \"Failed to call Gradio API\" }, { status: 500 });\n  }\n}\n\n\n\n\n\n\n\n\n// import { NextRequest, NextResponse } from \"next/server\";\n// import { Client } from \"@gradio/client\";\n\n// // ----------------- Helper Functions -----------------\n\n// function parseReport(report: string) {\n//   const get = (key: string) => {\n//     const match = report.match(new RegExp(`${key}:\\\\s*(.*)`));\n//     return match ? match[1].trim() : null;\n//   };\n\n//   return {\n//     confidence: parseFloat(get(\"Confidence Score\") || \"0\"),\n//     firstSeen: get(\"First Seen\"),\n//     lastSeen: get(\"Last Seen\"),\n//     tags: (get(\"Tags\") || \"\")\n//       .split(\",\")\n//       .map((t) => t.trim())\n//       .filter(Boolean),\n//     predictedThreat: get(\"Predicted Threat Level\") || \"Unknown\",\n//   };\n// }\n\n// function buildGauge(confidence: number, predictedThreat: string) {\n//   // Define threat zones on gauge:\n//   // Low: 0-40, Medium: 40-75, High: 75-100\n//   // Color code accordingly\n\n//   const gaugeColors: [number, number, string][] = [\n//     [0, 0.4, \"green\"],\n//     [0.4, 0.75, \"yellow\"],\n//     [0.75, 1, \"red\"],\n//   ];\n\n\n//   return {\n//     data: [\n//       {\n//         type: \"indicator\",\n//         mode: \"gauge+number+delta\",\n//         value: confidence,\n//         title: {\n//           text: `Confidence Score<br><span style=\"font-size:0.8em;color:#999;\">Predicted Threat: ${predictedThreat}</span>`,\n//           font: { size: 18 },\n//         },\n//         gauge: {\n//           axis: { range: [0, 100], tickwidth: 1, tickcolor: \"darkgray\" },\n//           bar: { color: \"darkblue\" },\n//           steps: gaugeColors.map(([start, end, color]) => ({\n//             range: [start * 100, end * 100],\n//             color,\n//           })),\n//           threshold: {\n//             line: { color: \"black\", width: 4 },\n//             thickness: 0.75,\n//             value: confidence,\n//           },\n//         },\n//       },\n//     ],\n//     layout: {\n//       margin: { t: 40, b: 0, l: 0, r: 0 },\n//       height: 350,\n//       width: 350,\n//       paper_bgcolor: \"#0f172a\",\n//       font: { color: \"#e2e8f0\" },\n//     },\n//   };\n// }\n\n// function buildTimeline(firstSeen: string | null, lastSeen: string | null) {\n//   const fs = firstSeen ? new Date(firstSeen) : new Date();\n//   const ls = lastSeen ? new Date(lastSeen) : new Date();\n\n//   // Format dates for display\n//   const options: Intl.DateTimeFormatOptions = { year: 'numeric', month: 'short', day: 'numeric' };\n//   const fsLabel = fs.toLocaleDateString(undefined, options);\n//   const lsLabel = ls.toLocaleDateString(undefined, options);\n\n//   return {\n//     data: [\n//       {\n//         // Invisible baseline for range shape positioning\n//         x: [fs, ls],\n//         y: [1, 1],\n//         mode: \"lines\",\n//         line: { color: \"transparent\" },\n//         hoverinfo: \"skip\",\n//       },\n//       {\n//         // Filled range between dates\n//         type: \"scatter\",\n//         x: [fs, ls, ls, fs, fs],\n//         y: [0.8, 0.8, 1.2, 1.2, 0.8],\n//         fill: \"toself\",\n//         fillcolor: \"rgba(14, 116, 144, 0.3)\",\n//         line: { color: \"rgba(14, 116, 144, 0)\" },\n//         hoverinfo: \"skip\",\n//         showlegend: false,\n//       },\n//       {\n//         // Marker for First Seen\n//         x: [fs],\n//         y: [1],\n//         mode: \"markers+text\",\n//         marker: { size: 14, color: \"#0bc5ea\" },\n//         text: [`First Seen: ${fsLabel}`],\n//         textposition: \"bottom center\",\n//         textfont: { color: \"#0bc5ea\", size: 12 },\n//       },\n//       {\n//         // Marker for Last Seen\n//         x: [ls],\n//         y: [1],\n//         mode: \"markers+text\",\n//         marker: { size: 14, color: \"#22d3ee\" },\n//         text: [`Last Seen: ${lsLabel}`],\n//         textposition: \"bottom center\",\n//         textfont: { color: \"#22d3ee\", size: 12 },\n//       },\n//     ],\n//     layout: {\n//       title: {\n//         text: \"Threat Activity Timeline\",\n//         font: { size: 20, color: \"#e2e8f0\" },\n//       },\n//       xaxis: {\n//         title: \"Date\",\n//         showgrid: true,\n//         zeroline: false,\n//         showline: true,\n//         linecolor: \"#444\",\n//         tickformat: \"%b %d, %Y\",\n//         tickangle: -45,\n//         tickfont: { color: \"#ccc\" },\n//       },\n//       yaxis: {\n//         visible: false,\n//         range: [0, 2],\n//       },\n//       margin: { t: 60, b: 80, l: 40, r: 40 },\n//       height: 350,\n//       width: 350,\n//       paper_bgcolor: \"#0f172a\",\n//       plot_bgcolor: \"#0f172a\",\n//       font: { color: \"#e2e8f0\" },\n//     },\n//   };\n// }\n\n\n// function buildTagBar(tags: string[]) {\n//   const counts: Record<string, number> = {};\n//   tags.forEach((tag) => (counts[tag] = (counts[tag] || 0) + 1));\n\n//   return {\n//     data: [\n//       {\n//         type: \"bar\",\n//         x: Object.keys(counts),\n//         y: Object.values(counts),\n//         marker: { color: \"#06b6d4\" },\n//       },\n//     ],\n//     layout: {\n//       title: \"Tag Frequency\",\n//       xaxis: { title: \"Tags\" },\n//       yaxis: { title: \"Count\" },\n//       margin: { t: 40, b: 50, l: 50, r: 30 },\n//       height: 350,\n//       width: 350,\n//       paper_bgcolor: \"#0f172a\",\n//       font: { color: \"#e2e8f0\" },\n//     },\n//   };\n// }\n\n// // ----------------- API Route -----------------\n\n// export async function POST(req: NextRequest) {\n//   try {\n//     const body = await req.json();\n//     const { user_input } = body;\n\n//     if (!user_input) {\n//       return NextResponse.json({ error: \"Input is required\" }, { status: 400 });\n//     }\n\n//     const client = await Client.connect(\"Bha19/cyber_project\");\n//     const result = await client.predict(\"/predict\", { user_input });\n\n//     const dataArray = result.data as [string, string | null];\n//     const [report] = dataArray;\n\n//     // Parse values from report string\n//     const { confidence, firstSeen, lastSeen, tags, predictedThreat } = parseReport(report);\n\n//     // Build graphs dynamically\n//     const graphs = [\n//       buildGauge(confidence, predictedThreat),\n//       buildTimeline(firstSeen, lastSeen),\n//       // If you want to keep tag bar, uncomment below:\n//       // buildTagBar(tags),\n//     ];\n\n//     return NextResponse.json({\n//       report,\n//       graph: graphs,\n//     });\n//   } catch (err) {\n//     console.error(\"Error calling Gradio API:\", err);\n//     return NextResponse.json(\n//       { error: \"Failed to call Gradio API\" },\n//       { status: 500 }\n//     );\n//   }\n// }\n"],"names":[],"mappings":"AAAA,2BAA2B;;;;;AAC3B;AACA;;;AAOA,uDAAuD;AACvD,SAAS,YAAY,MAAc;IACjC,MAAM,MAAM,CAAC;QACX,oDAAoD;QACpD,MAAM,KAAK,IAAI,OAAO,GAAG,IAAI,iBAAiB,CAAC,EAAE;QACjD,MAAM,QAAQ,OAAO,KAAK,CAAC;QAC3B,OAAO,QAAQ,KAAK,CAAC,EAAE,CAAC,IAAI,KAAK;IACnC;IAEA,MAAM,gBAAgB,IAAI,uBAAuB;IACjD,MAAM,aAAa,WAAW,kBAAkB;IAEhD,OAAO;QACL;QACA,WAAW,IAAI;QACf,UAAU,IAAI;QACd,MAAM,CAAC,IAAI,WAAW,EAAE,EACrB,KAAK,CAAC,KACN,GAAG,CAAC,CAAC,IAAM,EAAE,IAAI,IACjB,MAAM,CAAC;QACV,iBAAiB,IAAI,6BAA6B;IACpD;AACF;AAEA,SAAS,WAAW,UAAkB,EAAE,eAAuB;IAC7D,eAAe;IACf,MAAM,cAA0C;QAC9C;YAAC;YAAG;YAAK;SAAU;QACnB;YAAC;YAAK;YAAM;SAAU;QACtB;YAAC;YAAM;YAAG;SAAU;KACrB;IAED,OAAO;QACL,MAAM;YACJ;gBACE,MAAM;gBACN,MAAM;gBACN,OAAO;gBACP,OAAO;oBACL,MAAM,CAAC,wEAAwE,EAAE,gBAAgB,OAAO,CAAC;oBACzG,MAAM;wBAAE,MAAM;oBAAG;gBACnB;gBACA,QAAQ;oBAAE,QAAQ;gBAAI;gBACtB,OAAO;oBACL,MAAM;wBAAE,OAAO;4BAAC;4BAAG;yBAAI;wBAAE,WAAW;wBAAG,WAAW;oBAAU;oBAC5D,KAAK;wBAAE,OAAO;oBAAU;oBACxB,OAAO,YAAY,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,MAAM,GAAK,CAAC;4BACzC,OAAO;gCAAC,IAAI;gCAAK,IAAI;6BAAI;4BACzB;wBACF,CAAC;oBACD,WAAW;wBACT,MAAM;4BAAE,OAAO;4BAAW,OAAO;wBAAE;wBACnC,WAAW;wBACX,OAAO;oBACT;gBACF;YACF;SACD;QACD,QAAQ;YACN,OAAO;gBAAE,MAAM;gBAA2B,MAAM;oBAAE,OAAO;gBAAU;YAAE;YACrE,QAAQ;gBAAE,GAAG;gBAAI,GAAG;gBAAI,GAAG;gBAAI,GAAG;YAAG;YACrC,eAAe;YACf,cAAc;YACd,MAAM;gBAAE,OAAO;YAAU;YACzB,QAAQ;YACR,OAAO;QACT;IACF;AACF;AAEA,SAAS,cAAc,SAAwB,EAAE,QAAuB;IACtE,MAAM,SAAS,YAAY,IAAI,KAAK,aAAa,IAAI;IACrD,MAAM,SAAS,WAAW,IAAI,KAAK,YAAY,IAAI;IAEnD,kBAAkB;IAClB,MAAM,MAAM,CAAC,IACX,EAAE,cAAc,CAAC,WAAW;YAAE,MAAM;YAAW,OAAO;YAAS,KAAK;QAAU;IAEhF,MAAM,UAAU,IAAI;IACpB,MAAM,UAAU,IAAI;IAEpB,OAAO;QACL,MAAM;YACJ,mDAAmD;YACnD;gBACE,GAAG;oBAAC;oBAAQ;iBAAO;gBACnB,GAAG;oBAAC;oBAAG;iBAAE;gBACT,MAAM;gBACN,MAAM;oBAAE,OAAO;gBAAc;gBAC7B,WAAW;gBACX,YAAY;YACd;YACA,sDAAsD;YACtD;gBACE,MAAM;gBACN,GAAG;oBAAC;oBAAQ;oBAAQ;oBAAQ;oBAAQ;iBAAO;gBAC3C,GAAG;oBAAC;oBAAK;oBAAK;oBAAK;oBAAK;iBAAI;gBAC5B,MAAM;gBACN,WAAW;gBACX,MAAM;oBAAE,OAAO;gBAAqB;gBACpC,WAAW;gBACX,YAAY;YACd;YACA,4BAA4B;YAC5B;gBACE,GAAG;oBAAC;iBAAO;gBACX,GAAG;oBAAC;iBAAE;gBACN,MAAM;gBACN,QAAQ;oBAAE,MAAM;oBAAI,OAAO;oBAAW,MAAM;wBAAE,OAAO;wBAAG,OAAO;oBAAU;gBAAE;gBAC3E,MAAM;oBAAC,CAAC,OAAO,EAAE,SAAS;iBAAC;gBAC3B,cAAc;gBACd,UAAU;oBAAE,OAAO;oBAAW,MAAM;gBAAG;gBACvC,eAAe,CAAC,YAAY,EAAE,QAAQ,eAAe,CAAC;YACxD;YACA,2BAA2B;YAC3B;gBACE,GAAG;oBAAC;iBAAO;gBACX,GAAG;oBAAC;iBAAE;gBACN,MAAM;gBACN,QAAQ;oBAAE,MAAM;oBAAI,OAAO;oBAAW,MAAM;wBAAE,OAAO;wBAAG,OAAO;oBAAU;gBAAE;gBAC3E,MAAM;oBAAC,CAAC,MAAM,EAAE,SAAS;iBAAC;gBAC1B,cAAc;gBACd,UAAU;oBAAE,OAAO;oBAAW,MAAM;gBAAG;gBACvC,eAAe,CAAC,WAAW,EAAE,QAAQ,eAAe,CAAC;YACvD;SACD;QACD,QAAQ;YACN,OAAO;gBAAE,MAAM;gBAA2B,MAAM;oBAAE,MAAM;gBAAG;YAAE;YAC7D,OAAO;gBACL,OAAO;gBACP,UAAU;gBACV,WAAW;gBACX,WAAW,CAAC;gBACZ,UAAU;oBAAE,OAAO;gBAAU;YAC/B;YACA,OAAO;gBAAE,SAAS;gBAAO,OAAO;oBAAC;oBAAG;iBAAE;YAAC;YACvC,QAAQ;gBAAE,GAAG;gBAAI,GAAG;gBAAI,GAAG;gBAAI,GAAG;YAAG;YACrC,eAAe;YACf,cAAc;YACd,MAAM;gBAAE,OAAO;YAAU;YACzB,QAAQ;YACR,OAAO;QACT;IACF;AACF;AAGO,eAAe,KAAK,GAAgB;IACzC,IAAI;QACF,MAAM,OAAO,MAAM,IAAI,IAAI;QAC3B,MAAM,EAAE,UAAU,EAAE,GAAG;QAEvB,IAAI,CAAC,YAAY;YACf,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAoB,GAAG;gBAAE,QAAQ;YAAI;QACzE;QAEA,uCAAuC;QACvC,MAAM,SAAS,MAAM,+JAAM,CAAC,OAAO,CAAC;QACpC,MAAM,SAAS,MAAM,OAAO,OAAO,CAAC,YAAY;YAAE;QAAW;QAE7D,sDAAsD;QACtD,MAAM,YAAY,OAAO,IAAI;QAC7B,MAAM,CAAC,OAAO,GAAG;QAEjB,eAAe;QACf,MAAM,EAAE,UAAU,EAAE,SAAS,EAAE,QAAQ,EAAE,eAAe,EAAE,GAAG,YAAY;QAEzE,eAAe;QACf,MAAM,SAAsB;YAAC,WAAW,YAAY;YAAkB,cAAc,WAAW;SAAU;QAEzG,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE;YAAQ,OAAO;QAAO;IACnD,EAAE,OAAO,KAAK;QACZ,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAA4B,GAAG;YAAE,QAAQ;QAAI;IACjF;AACF,EASA,2DAA2D;CAC3D,2CAA2C;CAE3C,0DAA0D;CAE1D,yCAAyC;CACzC,mCAAmC;CACnC,iEAAiE;CACjE,6CAA6C;CAC7C,OAAO;CAEP,aAAa;CACb,8DAA8D;CAC9D,oCAAoC;CACpC,kCAAkC;CAClC,gCAAgC;CAChC,oBAAoB;CACpB,8BAA8B;CAC9B,0BAA0B;CAC1B,mEAAmE;CACnE,OAAO;CACP,IAAI;CAEJ,qEAAqE;CACrE,qCAAqC;CACrC,8CAA8C;CAC9C,8BAA8B;CAE9B,sDAAsD;CACtD,yBAAyB;CACzB,6BAA6B;CAC7B,wBAAwB;CACxB,OAAO;CAGP,aAAa;CACb,cAAc;CACd,UAAU;CACV,6BAA6B;CAC7B,sCAAsC;CACtC,6BAA6B;CAC7B,mBAAmB;CACnB,+HAA+H;CAC/H,gCAAgC;CAChC,aAAa;CACb,mBAAmB;CACnB,4EAA4E;CAC5E,wCAAwC;CACxC,+DAA+D;CAC/D,+CAA+C;CAC/C,qBAAqB;CACrB,iBAAiB;CACjB,yBAAyB;CACzB,kDAAkD;CAClD,+BAA+B;CAC/B,iCAAiC;CACjC,eAAe;CACf,aAAa;CACb,WAAW;CACX,SAAS;CACT,gBAAgB;CAChB,6CAA6C;CAC7C,qBAAqB;CACrB,oBAAoB;CACpB,kCAAkC;CAClC,oCAAoC;CACpC,SAAS;CACT,OAAO;CACP,IAAI;CAEJ,8EAA8E;CAC9E,6DAA6D;CAC7D,2DAA2D;CAE3D,gCAAgC;CAChC,qGAAqG;CACrG,+DAA+D;CAC/D,+DAA+D;CAE/D,aAAa;CACb,cAAc;CACd,UAAU;CACV,4DAA4D;CAC5D,uBAAuB;CACvB,qBAAqB;CACrB,yBAAyB;CACzB,0CAA0C;CAC1C,6BAA6B;CAC7B,WAAW;CACX,UAAU;CACV,wCAAwC;CACxC,2BAA2B;CAC3B,mCAAmC;CACnC,wCAAwC;CACxC,0BAA0B;CAC1B,gDAAgD;CAChD,oDAAoD;CACpD,6BAA6B;CAC7B,6BAA6B;CAC7B,WAAW;CACX,UAAU;CACV,mCAAmC;CACnC,mBAAmB;CACnB,kBAAkB;CAClB,gCAAgC;CAChC,kDAAkD;CAClD,4CAA4C;CAC5C,yCAAyC;CACzC,oDAAoD;CACpD,WAAW;CACX,UAAU;CACV,kCAAkC;CAClC,mBAAmB;CACnB,kBAAkB;CAClB,gCAAgC;CAChC,kDAAkD;CAClD,2CAA2C;CAC3C,yCAAyC;CACzC,oDAAoD;CACpD,WAAW;CACX,SAAS;CACT,gBAAgB;CAChB,iBAAiB;CACjB,4CAA4C;CAC5C,gDAAgD;CAChD,WAAW;CACX,iBAAiB;CACjB,yBAAyB;CACzB,0BAA0B;CAC1B,2BAA2B;CAC3B,0BAA0B;CAC1B,6BAA6B;CAC7B,mCAAmC;CACnC,0BAA0B;CAC1B,uCAAuC;CACvC,WAAW;CACX,iBAAiB;CACjB,0BAA0B;CAC1B,yBAAyB;CACzB,WAAW;CACX,gDAAgD;CAChD,qBAAqB;CACrB,oBAAoB;CACpB,kCAAkC;CAClC,iCAAiC;CACjC,oCAAoC;CACpC,SAAS;CACT,OAAO;CACP,IAAI;CAGJ,yCAAyC;CACzC,+CAA+C;CAC/C,mEAAmE;CAEnE,aAAa;CACb,cAAc;CACd,UAAU;CACV,uBAAuB;CACvB,kCAAkC;CAClC,oCAAoC;CACpC,wCAAwC;CACxC,WAAW;CACX,SAAS;CACT,gBAAgB;CAChB,gCAAgC;CAChC,kCAAkC;CAClC,mCAAmC;CACnC,gDAAgD;CAChD,qBAAqB;CACrB,oBAAoB;CACpB,kCAAkC;CAClC,oCAAoC;CACpC,SAAS;CACT,OAAO;CACP,IAAI;CAEJ,mDAAmD;CAEnD,iDAAiD;CACjD,UAAU;CACV,qCAAqC;CACrC,mCAAmC;CAEnC,yBAAyB;CACzB,mFAAmF;CACnF,QAAQ;CAER,kEAAkE;CAClE,uEAAuE;CAEvE,gEAAgE;CAChE,kCAAkC;CAElC,yCAAyC;CACzC,8FAA8F;CAE9F,kCAAkC;CAClC,uBAAuB;CACvB,iDAAiD;CACjD,4CAA4C;CAC5C,yDAAyD;CACzD,8BAA8B;CAC9B,SAAS;CAET,iCAAiC;CACjC,gBAAgB;CAChB,uBAAuB;CACvB,UAAU;CACV,oBAAoB;CACpB,uDAAuD;CACvD,gCAAgC;CAChC,gDAAgD;CAChD,wBAAwB;CACxB,SAAS;CACT,MAAM;CACN,IAAI","debugId":null}}]
}